/**
 * Application C - C++ App with Embedded Manifest
 * ===============================================
 * 
 * This example demonstrates embedding the NAH manifest directly in the
 * application binary at compile time. The manifest is:
 * 
 *   1. Defined as TOML in CMakeLists.txt
 *   2. Converted to binary TLV format by `nah manifest generate` at build time
 *   3. Converted to a C header with byte array
 *   4. Compiled into the binary in a platform-specific section
 *   5. Extracted by NAH from the binary at install time
 * 
 * This approach is useful for single-binary distributions where you don't
 * want a separate manifest.nah file.
 */

#include <nah/manifest_builder.hpp>  // For NAH_MANIFEST_SECTION macro

#include <iostream>
#include <cstdlib>
#include <cstdint>

// =============================================================================
// Embedded Manifest (compiled into binary section)
// =============================================================================
// The manifest bytes are generated at build time and stored in a platform-
// specific section that NAH can read from the binary.
//
// NAH_MANIFEST_SECTION places this in:
//   - macOS: __NAH,__manifest
//   - Linux: .nah_manifest
//   - Windows: .nah

NAH_MANIFEST_SECTION
static const uint8_t embedded_manifest[] = {
    // Include the generated byte array directly
    // This is initialized at compile time, not runtime
    #include "manifest_bytes.inc"
};

// =============================================================================
// Application Code
// =============================================================================

bool is_nah_managed() {
    return std::getenv("NAH_APP_ID") != nullptr;
}

std::string get_env(const char* name, const char* default_value = "") {
    const char* value = std::getenv(name);
    return value ? value : default_value;
}

int main(int argc, char* argv[]) {
    (void)argc;
    (void)argv;
    
    std::cout << "Application C v1.0.0 (Embedded Manifest)\n";
    std::cout << "=========================================\n\n";
    
    // Display manifest info
    std::cout << "Manifest Info:\n";
    std::cout << "  Embedded size: " << sizeof(embedded_manifest) << " bytes\n";
    std::cout << "  First 4 bytes: ";
    for (size_t i = 0; i < 4 && i < sizeof(embedded_manifest); ++i) {
        std::cout << std::hex << "0x" << static_cast<int>(embedded_manifest[i]) << " ";
    }
    std::cout << std::dec << "\n";
    
    // Verify magic number (NAHM = 0x4D48414E little-endian)
    if (sizeof(embedded_manifest) >= 4) {
        uint32_t magic = static_cast<uint32_t>(embedded_manifest[0]) | 
                        (static_cast<uint32_t>(embedded_manifest[1]) << 8) | 
                        (static_cast<uint32_t>(embedded_manifest[2]) << 16) | 
                        (static_cast<uint32_t>(embedded_manifest[3]) << 24);
        if (magic == 0x4D48414E) {
            std::cout << "  Magic: NAHM (valid)\n";
        } else {
            std::cout << "  Magic: invalid (0x" << std::hex << magic << std::dec << ")\n";
        }
    }
    std::cout << "\n";
    
    // Check NAH environment
    if (is_nah_managed()) {
        std::cout << "Running in NAH-managed environment:\n";
        std::cout << "  NAH_APP_ID=" << get_env("NAH_APP_ID") << "\n";
        std::cout << "  NAH_APP_VERSION=" << get_env("NAH_APP_VERSION") << "\n";
        std::cout << "  NAH_APP_ROOT=" << get_env("NAH_APP_ROOT") << "\n";
        std::cout << "  NAH_NAK_ID=" << get_env("NAH_NAK_ID") << "\n";
        std::cout << "  NAH_NAK_ROOT=" << get_env("NAH_NAK_ROOT") << "\n";
    } else {
        std::cout << "Running standalone (not NAH-managed)\n";
        std::cout << "  The embedded manifest will be used when installed via NAH.\n";
    }
    std::cout << "\n";
    
    std::cout << "Application C completed successfully.\n";
    
    return 0;
}
